# Presentation Requirements 

## Damien's Notes

- Plan carefully what you're going to say
- Should be approximately 20 slides, including a Title Slide and an outline of the talk
- We should be explaining what we've done in the past several months. Specifically, what work's happened between the start of the year an now
- You will want to present any results that you have.
- Be conscious of timing
- Remember that you are pitching to the audience. It's a form of communication. Think about the people in your field, and what you want them to get out of this presentation, what do you want them to know.
- Be sure to know what your key points are.
- Avoid writing a speech out in full and reading it.
- Remember it's about taking the audience from where they are to where you want them to be.
- People want to see enthusiasm about our work.
- Above all, remind us what the project is and why it's interesting.

## John Slaney's Requirements
Your talk should remind us all of what your project is, and why it's interesting, and then focus on progress of your project to date and any preliminary results you may have. Any plan you may have for finishing it in the remaining time should also get a mention.


------------------------

# Presentation Slides


## Intro slide
	- project is code understanding through visualisation
	- investigating code visualisations within the space of live coding

## Outline
	- Background
	- Importance
	- Study 1
	- Study 2
	- Results
	- Timeline
	- Progress
	- Remaining time
	- What will be achieved
	- What to take away

## Background
	- this project is focussing on assisting in code comprehension
	- code is often difficult to quickly understand
	- some observers may lack the experience to understand the software or the programming process

 	-realtime..
	- determined that visualisations would be the best approach to help improve source code comprehension
	- literature points to visualisation assisting with realtime understanding in complex domains (eg. infovis)
	- determined that *live coding* would be a good application domain because it revealed the programming process

	- what is live coding? 
		- some of you may already know
		- method of programming in front of an audience for artistic or informative purposes
		- the live coder displays their screen to an audience
		- live coder shows their code as they are working on it building a constantly running ever changing program
	- why is live coding relevant?
		-gives the audience insight into the programming process - this has been taken advantage of
	
	- taking a user-centred design approach

	- this project was started with the intention of combining the code visualisation domain and the music visualisation domain
	- the question we asked at the start of the year was: can we combine these two domain visualisations in a meaningful way to aid code comprehension?

## Interest/Importance of Project
	- number of implications
		- wider exposure to the programming process
		- wider value to education and entertainment within the space of live coding
		- interesting application of software engineering process
		- interesting applications to software engineering process

		- implications to high level understanding of code concepts and abstractions - useful for the wider population
		- implications in code comprehension among those experienced with programming - will be investigating this more in an upcoming study
		- application beyond live coding 
		- many types of programming and sdlc have features of live coding... application to these

## Progress (what has been developed/implemented)
	- iterative approach being used - investigate users, develop visualisations, test on users, repeat
	- working with the artist to elicit requirements
	- user-centred design... two surveys have been conducted to determine approaches to take
	- examining visualisations using didactic vs aesthetic and code visualisation vs music visualisation models... I'll talk about the results a little later 
	- number of visualisations prototyped

	### maybe
	- concepts from information visualisation highly relevant
	- visualisations developed inspired by Bertin's planar and 7 retinal variables... additional investigation of relevance of motion/ temporal information
	- balance between developing informative visualisations/annotations without being invasive
	- applying software engineering principles to the development and implementation of the software

## Study 1 - Background and Purpose
	field study and requirements
	- survey of live coding performance conducted at an art festival 
	- goal was to determine the best approach to begin developing visualisations
	- supplementary goal of determining the relationship between understanding and enjoyment
	- only projected the code without visualisations

## Study 1 - Data & Results
	- 14 respondents
	- demographics of the audience were those with little experience coding, but predominantly musical experience
	- the results were inconclusive
	- decided to conduct follow up interviews with some of those present
	- from this determined that visualisations appeared to influence enjoyment but
	- determined that focus should be on helping the audience understand the link between code changes and music changes
	- cemented the idea of using visualisations as the means of understanding

## Study 2 - Details and Purpose
	- built a number of visualisation prototypes 
	- one set based more around aesthetic nature of visualisations but still representing high level code structures
	- other on didactic aspects - visuals more educational in nature
	- overall, wanted to minimise number of data dimensions displayed... easier to examine... see what worked, what didn't
	- definitely keep below 3 dimensions as described in literature
	- gathered feedback from a survey
	- conducted to determine if the visualisations developed were heading in the right direction

## Study 2 - data & results
	- 41 respondents
	- gave us direction for improvement
		- projector screens
		- use of bold colours and fast changes did not contribute well to understanding
		- etc...
	- analysis determined that more information dimensions 
	- what is the strategy to improve?
		- previous visualisations had 1 or 2 dimensions of information
		- focus on simplicity

## Importance of Studies
	- determining the best approach to aid in understanding
	- testing out prototypes
	- outcome
		- approach of mapping number of functions active to visual objects on the screen provided visual interest but did not provide enough detail, while also competing with the highly detailed code. 
		- reactivity with the music provided an interesting visual dimension but did not necessarily provide more interesting details about the code
		- nevertheless, maximum three dimensions: 2 planar, 1 retinal appears to be the best approach as we are prototyping the next stage of the project 

## Timeline
	- tracking well
	- on schedule as defined by the initially presented timeline
		- 2 studies completed
		- 1 more planned... end of july or start of august
		- given the progress... potential for 1 more after that
	- have not had significant delays

## Remaining time
	- run another study... potential for another study after that
	- build some more prototypes
	- currently prototyping code manipulation visualisations, diff visualisations and code structure visualisations
	- further analysis of the data and investigation of the literature will inform which of these to develop further

## What do I intend to achieve
	- effective base level visualisations of code that indicate progress towards visual understanding of code
	- take advantage of existing areas (eg. infovis...) that have well developed visualsation concepts (eg. Bertin's 7 variables)
	- questions that we are still yet to ask
		- how can we better communicate the programmer's intention?
		- how can we better communicate the program's intention?

## 'Take a step backwards'
	- what is the purpose
	- what 
where is the action?
	- relevance to code comprehension?
		- application of visualisations to domain of 
	- relevance to visualisation?
		- application of visualisation concepts to different new areas
		- no one example of quality code visualisation
		- this will be a fundamental goal over the remaining part of the project
	- relevance to software engineering?
		- apart from the obvious educational benefit of exposing the programming process...
		- developing techniques for improving process
		- application of software engineering techniques to development of software vis tool
		- application of software engineering techniques to an 
	- link these three areas

## What to take away from this
	- project on track
	- visualisations show potential for influencing both understanding and enjoyment
	- will focus more effort for next study on linking code and visual to achieve original goal of understanding through visualisation

## Conclusion
	- thanks for listening
	- questions?








-----------------------------

# Potential Questions
- what software engineering approach has been taken?
	- heurisitic evaluation - over the next study
	- iterative approach
	- incremental development and the exposure of an incremental development process
	- investigation of abstraction and seperation of concerns within the context of visualsations
	- boehms seven principles:
		(1) manage using a phased life-cycle plan
		(2) perform continuous validation
		(3) maintain disciplined product control
		(4) use modern programming practices
		(5) maintain clear accountability for results
		(6) use better and fewer people
		(7) maintain a commitment to improve the process
	- human centred approach
	- approaching the question of complexity - what is the best way to integrate software engineering into other types of engineering... how do we make software engineering more useful to the general public?
- (art) apart from the abstract representation of code structures how do your visualisations relate to the code?
	-wanted to minimise dimensions through the first studies... easier to determine if it worked or not
	-literature suggests that the number of dimensions shown impacts ease of understanding
	-for the next phase visualisations intend to use code manipulation visualisations (eg. moving relevant code around), code diff visualisations (showing temporal changes to code) or code structure visualisations (showing code flow/structure graphically... eg. code paths as graph)
- grounded theory?
	- codes, concepts, categories, theories
	- certainly has relevance to this area
- why didactic vs aesthetic?
	- 
