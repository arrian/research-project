%!TEX root = thesis.tex

\chapter{Literature Review}


Software visualisation is building momentum within the space of live coding. This section seeks to identify the reason for this momentum and identify the purpose and potential for visualisations within this field.

% • Provide a context for the research 
% • Justify the research 
% • Ensure the research hasn't been done before (or that it is not just a "replication 
% study") 
% • Show where the research fits into the existing body of knowledge 
% • Enable the researcher to learn from previous theory on the subject 
% • Illustrate how the subject has been studied previously 
% • Highlight flaws in previous research 
% • Outline gaps in previous research 
% • Show that the work is adding to the understanding and knowledge of the field 
% • Help refine, refocus or even change the topic 

\section{Software}

Understanding changing software has been identified as one of the most important goals within the space of software engineering practice~\cite{Tao2012}. It is the nature of software to change~\cite{Brooks1995} and there is a need for not only the programmer to understand the software but also for knowledge transfer to take place between those modifying the software and those impacted by the changes~\cite{Tao2012}.

Programming languages are the formal languages of software. These languages are typically represented by source code in a plain text format. However, plain text format is limited requiring an interpretation step (parsing and compilation) to acheive a functioning program that can be understood by the computer~\cite{Badros2000}. The same occurs while programming. The programmer needs to comprehend the source code in order to make informed changes. In this case, the programmer conducts the interpretation step within the brain rather than the computer through a process of hypothesis creation, confirmation and refinement~\cite{Brooks1983}.

The steps involved in interpreting and comprehending source code have been comprehensively examined within the literature (see ~\cite{Novais2013,McLean2010a,Brooks1995,Desmond,Rajlich2002}). However, although many studies discuss the limitations of text-based source code, comparatively few have conducted empirical user studies examining the effectiveness of alternative representations of source code.

The concept of alternative source code representations is not new. Alternative representations of the source code include diagrams~\cite{Rumbaugh2004}, visual languages~\cite{Cox2007} and combinations of the two (e.g.~\cite{Lucanin2011}). Modern software development environments may also include tools that allow for alternative representations of code~\cite{Cox2007}. Diagrams, visual languages and modern software development environments vary greatly in the relation to the source code with some representations presenting a highly simplified source code representation compared to finer grained specific representations~\citetemp{x}. Despite the differences in the level of abstraction and goal of the alternative representations, these approaches are all related through their common use of visualisation techniques.

\section{Visualisation}

Visualisation is widely understood as ``the use of computer-supported, interactive, visual representations of data to amplify cognition''~\cite{Card1999}. Further extensions of this definition discuss the need to perform cognitive work more efficiently~\cite{Ware2013a} and the need to transfer knowledge~\cite{Burkhard}. These definitions are summarised in the model shown in Figure~\ref{fig:model-of-visualisation}.

\begin{figure}
  \centering \includegraphics[width=\columnwidth]{../images/diagrams/wijk-model-of-visualisation.pdf}
  \caption{Generic model of visualisation \protect\cite{VanWijk2005}.}
\label{fig:model-of-visualisation}
\end{figure} 

% -alternative aesthetic view? \cite{VanWijk2005} discusses the technology vs art vs science perspective

% some foundational softvis references
Software visualisation is the process of representing the characteristics of computer programs visually~\cite{Stasko1992} in order to improve understanding~\cite{Diehl2007}. The advantage of providing a visual representation over the more traditional text-based representation is that the text-based approach does not take full advantage of the human visual information processing capability~\cite{Myers1989}.

Initial efforts to classify software visualisations identified two axes: whether the visualisation illustrated the code, the data or the algorithm and whether the visualisation was static or dynamic~\cite{Myers1989}. Following taxonomies characterised software visualisations according to the aspect of the program, the abstractness of the visualisation, the animation and the automation of the visualisation~\cite{Stasko1992}.

Although it is the nature of software to change, static diagrams have traditionally been used to represent software systems visually. These diagrams typically show the structure (class diagrams) or function (state diagrams) of a software system at a specific moment in time~\cite{Rumbaugh2004}. The usefulness of these diagrams lies in their ability to represent fundamental structures within the program more concisely than the source code itself~\citetemp{x}. However, the usefulness of these diagrams declines as they become more comprehensive and less abstract~\citetemp{x} and these static diagrams must be continuously updated or generated to keep up with the ever changing software~\citetemp{x}.

Visual languages provide an alternative method of interaction with the software development process. However, visual languages are often not suited to general purpose programming~\cite{Myers1989}, providing only a subset of a full-featured text-based language. Studies based around visual languages show...~\citetemp{x}.

Modern software development systems usually consist of an \ac{IDE} to manipulate source code. These systems may feature source code annotations and allow the programmer to interact with the running program's source code~\citetemp{x}. These modern \acp{IDE} emphasise the relationship between the source code and the running programming but are still fundamentally tools for source code manupulation~\citetemp{x}. Despite the age of some of these tools, only the initial steps have been taken in order to implement and evaluate methods of communicating source code intent and mapping to the active program~\citetemp{x}.

A number of studies hint at the limitations of static diagrams, visual languages and modern software development environments~\citetemp{x} and identify the need for alternative software reprentations and evaluation of their effectiveness~\citetemp{x}. 

Visualisations have the capacity to present information more effectively than traditional programming languages. Nevertheless, software visualisations still require significant development to benefit in the understanding of the complexity of software ~\cite{Baecker1995}. Effective software visualisations contribute to making software easier to understand, reflecting the software's history through the lifecycle, facilitating the transfer of knowledge from the programmer to the observer, making important structures visible and managing software complexity~\cite{Baecker1995}.

In a process-oriented activity such as live coding, different code visualisation techniques are necessary~\cite{McLean2010a,Magnusson2013}. However, these academic treatments of code visualisation in live coding adopt a survey-based approach, and the techniques discussed have not been subject to empirical evaluation.\\
-use this paragraph to link to the next section

\section{Live Coding}

Live coding can be broadly defined as writing a program while it runs~\cite{Ward2004}. More specifically, live coding is identified as the artistic process of musical and visual expression through programming~\cite{Collins2003}.

% Why live code?\\
% -what does it contribute?\\
% -improvisation?\\
% -computational creativity. \cite{Mclean}

The concept of ``liveness'' is covered comprehensively within the literature~\cite{Auslander,Masura2007}.\\
-why is liveness important\\
-should it be used as a metric\\
-what are the gaps in the investigation of liveness

Live coding is in a unique position to combine both source code and software visualisation techniques~\cite{McLean2010a}. This is due to the approach of live coding involving effective sensory communication, a goal of transparency of the coding process, and direct manipulation and refinement of the running program. These approaches are outlined below.

Live coding is built around communicating visually and audibly. This extends beyond the physical process of programming. Human input is visible in the creative process, demonstrating a link between physical actions and artistic output \cite{Mclean}. Studies of live coding regarding the effects of visual and audible communication have indicated...

Live coding has a history exposing audiences to code with the goal of live coding to ensure the transparency of the coding process~\cite{Collins2011,McLean2010a}. It provides a space in which there is a direct mapping from the human interaction with the source code to the musical or visual output~\cite{Mclean}. This relationship allows for visuals to map the interaction with the output~\citetemp{x}.

Lastly, live coding allows for direct manipulation and refinement of the running program~\cite{Swift2013}. This provides the capacity for uninterrupted visualisation of the dynamic aspects of the program~\citetemp{x} combined with the static nature of the source code. Similarly, manipulation and refinement of the running program allows for manipulation of the software visualisation~\cite{McLean2010a} to effectively communicate intent~\citetemp{x}.

Studies conducted into the communication of the live coding process indicate...

\section{Programmer and Observer}

The relationship between the programmer and the observer has significant implications not just within the field of live coding but also within software engineering practice.

-existing programmer/observer such as pair programming

-the artist and the audience within live coding

Audiences are yet to be surveyed as to whether the projected code within a live coding performance gives a greater sense of communication between the programmer and observer or a greater sense of alienation~\cite{Mclean2011}.

\section{Enjoyment and Understanding}

There is currently a search for software visualisations that increase enjoyment and understanding~\cite{McLean2010a}. Here enjoyment refers to the perceived benefit gained from observing the visualisations regardless of the level of understanding. Understanding refers to the ability of an observer or audience to comprehend the abstract thinking process of the programmer.

Enjoyment is the most common reaction to the positive effect of media~\cite{Vorderer2004}. Increasing enjoyment is one of the fundamental goals of the modern media entertainment industry and with increased enjoyment usually characterised by ``pleasurable affective response to a stimulus''~\cite{Brock2004}. 

Enjoyment results in increased attention to the stimulus and has been suggested to increase learning outcomes~\citetemp{x}.\\
-how do these factors relate to understanding?\\
-how do these factors relate to visualistions?\\
-how can these two factors contribute to effective visualisations?\\
-the concept assignment problem~\cite{Biggerstaff1994}

Understanding of a particular program is said to be achieved when the program can be explained ``in terms that are qualitatively different from the tokens used to construct the source code''~\cite{Biggerstaff1994}. Source code comprehension has a large body of research both within the understanding of text-based source code~\citetemp{x} and within the space of software visualisation~\cite{Hosking2005}.

In the space of live coding, this understanding is required to avoid a sense of distraction or exclusion~\cite{McLean2010a}. Furthermore, understanding software while it is changing presents an additional challenge~\cite{Eisenbarth2003}.

Understanding and enjoyment are often considered opposite concepts when implementing strategies to increase one or the other. 
% -enjoyment is not completely separable from understanding. (not dual?)\\
% -why can we not separate the two?\\
% -what is the duality?\\
% -how does this relate to visualisations?

\section{Didacticism and Aestheticism}

Enjoyment and understanding are often closely associated with the concepts of didacticism and aestheticism.

Didacticism refers to the ultimate goal of teaching. This approach mirrors the concept of understanding from the previous section. A didactic approach intends to increase the level of understanding.
% -what is didacticism?\\
% -how does it relate to visualisations?\\
% -how does it relate to education?

Aestheticism refers to the ultimate goal of appealing to the senses. This approach mirrors the concept of enjoyment from the previous section. An aesthetic approach intends to increase visualisation usability and increase retention~\cite{Cawthon2007}. Live coding has much potential and opportunity to evaluate and improve aesthetic effect~\cite{Bell}.

The artistic nature of the live coding field cannot be ignored when evaluating the effect of aesthetic and didactic approaches on the enjoyment and understanding of the audience.
% -how does it relate to art?\\
% -why is it still a good approach for evaluating understanding.

Software visualisations within the space of live coding have the potential to manipulate these two variables~\cite{Iru,McLean2010a}. For example, by increasing visual interest it may be possible to increase aesthetic appeal. Though increasing aesthetic appeal may reduce didacticism with increased visual complexity causing confusion.

Questions raised within the literature suggest that it may be possible to combine or balance the goals of didacticism and aestheticism in order to manipulate understanding and enjoyment~\citetemp{x}. On the other hand, it may be that these two concepts cannot be completely separated.

The educational aspects of software visualisations have been examined in a number of studies~\citetemp{x} though few have applied these visualisations to areas outside of the field of software engineering and fewer still have investigated software visualisations targeted at those with no programming experience.

There has been an initial examination of the aesthetics in graph drawing~\citetemp{x} and within the space of software graph visualsations~\citetemp{x}, though no studies have examined the effectiveness of process-driven software visualisations. This is particularly the case for the examination of live coded visualisations and the effect on audiences.

Some frameworks for both aesthetic evaluation of visualisations~\cite{Cawthon2007,Purchase1996} and didactic evaluation of visualisations~\cite{VanWijk2005} have been developed though a thorough evaluation of the combination of the two concepts has not been considered.

% Final words
Reviewing the model in Figure~\ref{fig:model-of-visualisation} from the didactic and aesthetic perspective identifies one major limitation. Within this model, a gain in knowledge is the only measurement of value and the only identified method for increased cognitive performance and increased exploration.\\
-has the literature identified a need to redefine the model in terms of the relationship between understanding and enjoyment, didacticism and aestheticism?

% Need to link to next chapter here. Why did we conduct the exploratory field study?



