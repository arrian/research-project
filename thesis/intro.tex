%%
%% Template intro.tex
%%

\chapter{Introduction}
\label{cha:intro}

-code is often difficult to quickly understand
-some observers may lack the experience to understand the software or the programming process

Additionally, how we program does not achieve the goals we set out to achieve (from $https://www.youtube.com/watch?v=1f13TTu_X9k$, taken from presentation reimagining programming languages):
-programming is unobservable (looking at the system through a keyhole)
-programming is indirect (no direct feedback)
-programming is incidentally complex (complexity not inherent in the problem that we need to solve)




-how can we improve source code comprehension?
-how can we aid understanding of the programming process?
-better yet, how can we better communicate the programmers intention?

-techniques such as modelling or code documentation aren’t dynamic or flexible
-don’t allow for close to realtime understanding
-an effective technique is the use of visualisations
-it would be valuable to use visualisations as a means to communicate the programmer’s intention


\section{Summary - remove}

-this thesis will explore code visualisations
-specifically, it will investigate visuals within the combination of the domains of software and music
-will be using Iive coding as a platform and case study for this (will discuss later)
-will develop and test code visualisations on audiences with audiences of varied levels of experience with programming, addressing code comprehension

\section{Background}
\label{sec:basis}


\subsection{Live Coding}

-live coding is a platform for bridging these two domain visualisations 
-what is live coding?
-method of programming in front of an audience for artistic or informative purposes
-the live coder displays their screen to an audience, showing their code as they are working on it building a functional program
-makes use of interactive programming environments 
-program running while changes are being made 
-often focusses on improvisation - the programmer often has to think on their feet

-what does live coding achieve?
-gives the audience insight into the programming process - i’ll be taking advantage of this


\section{Theoretical Framework}
\label{sec:framework}




\subsection{Taxonomy}


-Goal: categorising existing visualisations
-Gaps in existing models: elaboration of dynamic software visualisation taxonomies, taxonomy of music visualisation

-High level features:
	-Shape
	-Size
	-Orientation
	-Dimensionality
	-Colour
-‘Rethinking Visualisation: A High Level Taxonomy' discusses lower level taxonomy including - spacial relationships, numeric trends, patterns, connectivity and filtering

-distinction between scientific visualisation and information visualisation (Infovis discussed in Rethinking Visualization: A High-Level Taxonomy)
-Information visualisation vs Scientific visualisation - “infovis when spacial representation is chosen, scivis when spacial representation is given”
-Taxonomy developed within this article consists of {discrete, continuous} vs display attributes (eg. given, constrained, chosen) per the design model
-Discussed in A Principled Taxonomy of Software Visualisation (1993)
-Myers (1986) classifies using level of abstraction vs level of animation. (Visual Programming, Programming by Example… A Taxonomy) Also uses {static, dynamic} vs {code, data}. Minimal discussion of dynamic visualisations; no elaboration.

-Most effective visualisation technique might be \"Self-illustrating phenomena\" \\

Both code and music present a wide variety of visualisation techniques. These techniques will be summarised below.


\subsubsection{Code Visualisation}
\paragraph{Code Augmentation}
Visuals based on Code Augmentation (eg. infographics, annotations, sparklines)\\
Visuals based on Code Augmentation
-infographics
-annotations (visual code annotations for cyberphysical programming)
-sparklines (Visual Monitoring of Numeric Variables Embedded in Source Code)
-etc

\paragraph{Code Abstraction}
Visuals based on Abstraction (eg. scheme bricks, gource, code flow)\\

Visuals based on Abstraction
-scheme bricks
-gource
-code flow
-etc
\paragraph{Software Domain Visualisations}
Domain Visualisations (eg. fluid source code views, indentation, class diagrams)\\

Domain Visualisations
-understood by the domain, not necessarily useful for observers
-eg. eclipse, visual studio code displays, auto updating class diagrams etc
-fluid source code views (Fluid Source Code Views for Just In-Time Comprehension)
-class diagrams
-debugging
-tracing

\subsubsection{Music Visualisation}
-music is similar to software in a number of ways
-often has standardised notation
-expression may diverge from notation
-visual representation is by default static
-can be visualised using dynamic methods
-understanding can augmented with visualisation techniques

\paragraph{Generative Visualisations}
Generative Visualisations (eg. frequency wave, VLC/iTunes visualisations)\\

Generative Visualisations
-\"generates animated imagery based on a piece of music\"
-eg. change with loudness and frequency spectrum
-VLC, iTunes etc.
-visualisations that respond to music

\paragraph{Associative or Emotive Visualisations}
Associative or Emotive Visualisations (eg. video art, sampled video)\\

Associative or Emotive Visualisations
-includes areas such as synaesthesia (Movies from Music)
-eg. video art, sampled video with sampled music
-extension/exploration of Emotion-based Music Visualisation using Photos
-Classifications including: sublime, sad, touching, easy, light, happy, exciting, grand


\paragraph{Music Domain Visualisations}
Domain Visualisations (eg. ableton, sheet music)\\

Domain Visualisations
-understood by the domain, not necessarily useful for observers (A Visualisation of Music)
-could include music creation tools, for example abelton etc.
-graphic representations that have one-to-one mapping
-direct visualisation
-eg. sheet music (again, A Visualisation of Music)




\subsection{Design}

-NOTE: make it clear that this is not intended to be a visual programming language environment. The intention of this project is to assist in code comprehension 

\subsubsection{Cognitive Dimensions of Notation}
$http://en.wikipedia.org/wiki/Cognitive_dimensions$

\subsubsection{Visual Primitives}

structural units include line, shape, color, form, motion, texture, pattern, direction, orientation, scale, angle, space and proportion.

deutsch limit (max 50 visual elements onscreen)


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
