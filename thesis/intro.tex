%!TEX root = thesis.tex

\chapter{Introduction}
\label{chap:introduction}

\begin{chapquote}{Frederick Brooks, \textit{The Mythical Man-Month}}
``In spite of progress in restricting and simplifying the structures of software, they remain inherently unvisualizable, thus depriving the mind of some of its most powerful conceptual tools. This lack not only impedes the process of design within one mind, it severely hinders communication among minds.''
\end{chapquote}

-introduce the topic...\\
-introduce visualisations...\\
-introduce live coding...\\

This thesis proposes that ``code visualisation improves observer understanding and enjoyment''. More specifically, this thesis investigates the question ``can the application of visualisation techniques to live coding enhance audience experience by increasing understanding and enjoyment?''.\\

Definitions...\\
-define live coding, understanding and enjoyment\\
-define visualisation techniques\\
-define the programmer and observer relationship\\
-define audience experience\\

Introductory discussion/summary...\\
-this thesis will explore code visualisations\\
-specifically, it will investigate visuals within the combination of the domains of software and music\\
-will be using Iive coding as a platform and case study for this (will discuss later)\\
-will develop and test code visualisations on audiences with audiences of varied levels of experience with programming, addressing code comprehension\\

\section{History}

-some useful quotes to be summarised somewhere... maybe in introduction-history or lit review
``Software is invisible and unvisualizable. Geometric abstractions are powerful tools. The floor plan of a building helps both architect and client evaluate spaces, traffic flows, views. Contradictions become obvious, omissions can be caught. Scale drawings of mechanical parts and stick-figure models of molecules, although abstractions, serve the same purpose. A geometric reality is captured in a geometric abstraction.''~\cite{Brooks1995}

``In spite of progress in restricting and simplifying the structures of software, they remain inherently unvisualizable, thus depriving the mind of some of its most powerful conceptual tools. This lack not only impedes the process of design within one mind, it severely hinders communication among minds.''~\cite{Brooks1995}



% For most of its history source code has been displayed as simple text due to the expressiveness of this format and despite its inefficiencies. It is only recently, due to ever increasing programming language complexity and increasing computational power, that code annotations and syntax highlighting have become more commonplace. Nevertheless, these visual enhancements rarely provide information beyond the basic grammar of the language they are intended to augment. The limitations of this approach are becoming ever more apparent as programming languages and interactive programming environments move towards the need for real-time comprehension and a need to understand the source code within the context of a running program.\\

% The problem of understanding code within a running environment is complex. The fact that programming concepts are fundamentally different to human understandable concepts~\cite{Biggerstaff1994} presents challenges in communicating the complex nature and intention of the program. The fundamental complexity lies within the translation from code to the brain; the programming concepts to the human understandable concepts.\\

% The human brain is highly proficient in pattern recognition and there is evidence to suggest that visualisations can take advantage of this proficiency to enhance understanding. It would be informative to investigate this translation using visual representations to translate and assist in the understanding of program concepts.\\

\section{Background}

Existing code visualisations...\\
-gource \cite{Caudwell2010}\\
-code flower\\
-other existing visualisation examples.\\

\section{Structure}

The structure of this thesis consists of an initial field study (Chapter~\ref{chap:exploratory-field-study}), discussion of the first iteration of the visualisation prototype (Chapter~\ref{chap:visualisation-design}), a user study examining the prototype visualisation approach (Chapter~\ref{chap:user-study}), discussion of the refinement of the prototype visualisations (Chapter~\ref{chap:visualisation-refinement}), a second user study examining the refined visualisations (Chapter~\ref{chap:follow-up-user-study}), summary of the results and contributions (Chapter~\ref{chap:summary}), and finally a conclusion summarising the thesis (Chapter~\ref{chap:conclusion}).

% -----------------------------------

% [from live coding paper]

% ``Show us your screens\ldots Code should be seen as well as heard'',
% declares the draft manifesto of ``TOPLAP''~\cite{Toplap}, an
% international organisation devoted to the artistic performance
% practice of ``live coding''. In live coding, computer code is written
% in front of a live audience to generate music and visuals in real
% time. The ``show us your screens'' rhetoric underscores the need for
% authenticity to distinguish this artform from similar (but non-live)
% computational arts practices.

% But what is the benefit of the live coder showing their screen? In a
% live coding performance, non-expert live coding audience members spend
% much of their time staring at raw (usually text-based) computer code.
% Until now, little empirical study has been undertaken to gauge an
% audience's understanding of that computer code and whether, from an
% audience perspective, code really should be ``seen as well as heard''.

% Traditional approaches to source code visualisation
% (see~\cite{Novais2013} for a review) often focus on structure of the
% source code (e.g. visualising complex object/class relationships)
% rather than the \emph{process} of programming. In a process-oriented
% activity such as live coding, different code visualisation techniques
% are necessary~\cite{McLean2010a,Magnusson2013}. However, these
% academic treatments of code visualisation in live coding adopt a
% survey-based approach, and the techniques discussed have not been
% subject to empirical evaluation.

% In this paper, we examine the audience's experience of the displayed
% code during live coding performances and to see whether code-driven
% visualisations might improve both the audience enjoyment and the
% audience understanding of these performances. This exploration takes
% place initially through the results of an exploratory field study at a
% contemporary arts festival, and subsequently through a lab-based
% follow-up user study.


% -----------------------
% Questions to ask (thesis post-mortem):

% What was your thesis about?
% What did you find out?

% -------------------

% didactic vs aesthetic
% industry vs art

% The purpose of software engineering is to bring together ideas from many fields into one - developing good software that is fit for purpose and fit for use. The systems engineering perspective of software engineering. However, one area where software engineering has had little influence and little influence has been taken from is the area of art.


% Often put on separate ends of the spectrum... unless you are building software for multimedia practice - even then though...


%%--------------------------------------------

% Software engineering practice and art are often considered opposing ends of the spectrum. 

% This project will examine the relationship between aesthetics and educational aspects of code visualisiatons applied to two fields - an industry based application and a new media art application. 

% Questions:
% (1) What about the multimedia arts domain? What about the application of aesthetics and consideration for design within the space of software engineering? Both are widely accepted areas

% (2) Why don't we even have the most simple of tools to visualise changing code structure? Too complex? Not helpful? Why must code structures be designed statically?

% (3) Where is the future of programming? It is esentially the same as it was when it was first created. (Focus on higher abstractions in some fields? Move towards less abstraction...) Yet today it claims to be interactive/responsive etc...

%%--------------------------------------------

% -code is often difficult to quickly understand
% -some observers may lack the experience to understand the software or the programming process

% Additionally, how we program does not achieve the goals we set out to achieve (from $https://www.youtube.com/watch?v=1f13TTu_X9k$, taken from presentation reimagining programming languages):
% -programming is unobservable (looking at the system through a keyhole)
% -programming is indirect (no direct feedback)
% -programming is incidentally complex (complexity not inherent in the problem that we need to solve)

%%--------------------------------------------

% -how can we improve source code comprehension?
% -how can we aid understanding of the programming process?
% -better yet, how can we better communicate the programmers intention?

% -techniques such as modelling or code documentation aren’t dynamic or flexible
% -don’t allow for close to realtime understanding
% -an effective technique is the use of visualisations
% -it would be valuable to use visualisations as a means to communicate the programmer’s intention

%%--------------------------------------------



