%!TEX root = thesis.tex

\chapter{Visualisation Design}
\label{chap:visualisation-design}

Following the exploratory field study (see Chapter~\ref{chap:exploratory-field-study}), a strategy for visualisation prototyping and evaluation was developed. This strategy was based on the analysis of the literature and the evaluation of the results of the exploratory field study. A collaborative approach was taken, working with a live coder to integrate visuals into the live coding process. The rationale behind developing visualisations, the approach taken to develop the visualisations, and the resulting visualisations, are discussed in this chapter.

\section{Rationale}

% {\color{red}\cite{Ware2013a,McLean2010a,Purchase1996} will be useful here.}

The exploratory field study established and examined questions regarding the projection of source code during live coding performances including: ``Is source code the best method of communicating the performance?'' and ``Are there alternative methods?''. Results suggested that there was potential for visualisation of the live coding process and identified understanding and enjoyment as valid measures of the audience.

Evaluation of the literature had identified the need for visualisations that helped live coding audiences understand and enjoy the live coding performance. To this end, two sets of visualisations were developed. The first was intended to increase the enjoyment of the audience, enhancing aesthetic appeal and was labelled the ``aesthetic visualisation''. The second was intended to communicate the live coding process, help the audience to understand the programmatic aspects of the performance and was labelled the ``didactic visualisation''.

In order to systematically and efficiently develop a visualisation design strategy, two stakeholders were identified. These included the live coder and the intended audience.

Evaluation of the visualisation prototype required application to a live coding performance. To achieve this, the live coder would need to apply the visualisations to a live performance. To this end, discussions with the live coder identified requirements including simultaneous display of source code and visualisations and visualisations depicting the progression of the performance accurately. It was also identified that performance of the visualisations was essential, as the nature of live coding is realtime, and reliability, as a single failure in the visualisations could cause catastrophic failure within the live coding performance.

Typical live coding performances consist of around four instruments. This is to maintain musical consistency throughout the performance but to also allow for musical progression. It was identified that to accurately visualise a live coding performance, the visuals would also need to have similar progression while also maintaining consistency throughout the performance using a visual palette of colours, shapes and animations.

The intended audience was identified as a critical stakeholder in the ultimate effectiveness of the visualisations developed. The audience evaluated in the initial field study provided the basis for these requirements.

% The source code caused fatigue, however to understand the program, seeing the whole development process (all the code) was necessary.

% Requirements identified by the audience during the intial field study indicated that...
% -discuss audience requirements identified from first study

Fundamental to live coding is the performance element. Live coding requires a reliable programming environment. Visualisations developed for this environment required that the chance of failure were minimised. To mitigate the chance of a failure in the live coding environment, a test strategy was developed for the visualisations to ensure that they did not cause unrecoverable failures and did not cause memory leaks.

% Timeline constraints were also identified as a potential risk factor in the development and evaluation of the visualisations. Mitigation involved developing a flexible, iteration based development plan with estimated milestones.

% -ensure that the visualisations would provide a benefit and would not negatively impact the performance... mitigated by the iteration based approach to developing the visualisations

% -ensure that the visualisations would not interfere with the live coder...

\section{Design}

\begin{figure}
  \centering \includegraphics[width=\columnwidth]{../images/diagrams/knowledge-flow-initial.pdf}
  \caption{Knowledge flow from programmer to observer as directed by the visualisation technique employed.}
\label{fig:knowledge-flow-initial}
\end{figure}

The intial iteration of the visualisation prototype consisted of two separate conditions. Each condition consisted of four visual progressions with the intention of representing the addition and removal of instruments during the live coding performance. Visualisations employed dynamic analysis of the running program to generate the visuals. The model of knowledge flow from programmer to observer is shown in Figure~\ref{fig:knowledge-flow-initial}.

The first visualisation condition was labelled the ``aesthetic'' condition reflecting the intention to improve enjoyment during the live coding performance. The second visualisation condition was labelled the ``didactic'' condition with an intended goal of improving understanding during the live coding performance.

% The design of the initial visualisations focussed on the application of the literature on visualisation design to the field of software visualisation and the application to the visualisation of live code.

% -music visualisation is an extremely rich and open-ended task, so to guide the development of the visualisations for our lab study...

% -guidelines set out by mclean were used in understanding the application of visualisation to live coding...
% \cite{McLean2010a}...

% -guidelines set out by ware were used in developing the visualisations...
% % - what are the guidelines used
% \cite{Ware2013a}...


A number of guidelines from a variety of sources were adapted to develop these visualisations. A selection of these guidelines are listed below and are referred to in the following sections to identify the basis of design decisions:
\begin{itemize}
\item Design for important elements to be percieved quickly \cite[p.~14]{Ware2013a}~\glab{guide:sensory-capabilities}
\item Use colour saturation to represent numerical values \cite[p.~117]{Ware2013a}~\glab{guide:color-saturation}
\item ``Use strong preattentive cues before weak ones where ease of search is critical'' \cite[p.~156]{Ware2013a}~\glab{guide:preattentive-cues}
\item Use the dominant variables of colour and size to help focus attention \cite[p.~45]{Borgo2013}~\glab{guide:dominant-channels}
\item Use a distinctive feature channel for a popout effect \cite[p.~157]{Ware2013a}~\glab{guide:distinctive-feature-channel}
\item Related symbols should be placed in close proximity \cite[p.~181]{Ware2013a}~\glab{guide:close-together}
\item Use words when the number of categories is few and space is available \cite[p.~321]{Ware2013a}~\glab{guide:words-on-chart}
\item Text should appear ``as close as possible to the related parts of a diagram'' \cite[p.~333]{Ware2013a}~\glab{guide:close-text}
\item ``A one-to-many mapping makes use of redundancies by mapping a data variable to multiple glyph channels. Such a mapping can reduce the risk of information loss by encoding important variables multiple times'' \cite[p.~52]{Borgo2013}~\glab{guide:redundancy}
\item ``Important variables should be enhanced in the visualization\ldots~the mapping should guide the user's focus of attention'' \cite[p.~52]{Borgo2013}~\glab{guide:attention}
\end{itemize}

A number of general standards exist for the design of interfaces and the standard approaches for multimedia \ac{HCI} design (see~\cite{ISO2002} and \cite{Bevan2006}). However, as the space of the visualisation of live coding has not been fully defined, these standards have yet to be evaluated as relevant and effective. In these visualisations, these standards were taken as guidelines to allow for the possibility of the emergence of new, effective visualisation techniques.

Colour schemes, although varying slightly throughout the visualisations, consisted of a colour palette of red, orange and blue with red and orange used heavily throughout the visualisations and blue used for emphasis and visual interest (Guidelines~\ref{guide:dominant-channels} and \ref{guide:color-saturation}). Animations were used throughout to draw attention to parts of the visualisations (see Guideline~\ref{guide:attention}).

\input{images/didactic-visualisations}

\subsection{Didactic Visualisation}
\label{sec:didactic-visualisation}

The didactic visualisation (shown in Figure~\ref{fig:didactic-visualisations}) attempted to communicate \emph{information} about the actions of the programmer, prominently displaying the \emph{names} of the active (source code) functions and the ``time until next execution'' for each function. This ``time until next execution'' known as the ``callback rate'' was a primary feature of the programming environment and an essential part of musical live coding. Bright colours and solid shapes were used to ensure constant visibility and to communicate the intention of the underlying code (see Guidelines~\ref{guide:sensory-capabilities} and \ref{guide:dominant-channels}). 

The stages of this visualisation attempted to address the issues indicated during the exploratory field study. These included the lack of an overview of the source code and program behaviour, the difficulty in linking changes to the source code and the flicking between source code screens. The didactic visualisations proceeded through four stages, with progression made depending on the number of active functions (instruments).

Phase one (see Figure~\ref{fig:didactic-one}) displayed the name of the one active function in the centre of the screen (see Guideline~\ref{guide:attention}). Two other major visual elements were present including a short circular line segment rotating and a pulsing circle. Both visual elements were mapped to the callback rate of the active function (see Guideline~\ref{guide:redundancy}). Phase two (see Figure~\ref{fig:didactic-two}) displayed the name of two active functions. Two ring-shaped visual elements represented the two functions. Each ring-shape was divided into ten segments with each segment coloured according to the callback progress of the active functions. Phase three (see Figure~\ref{fig:didactic-three}) displayed three active functions as pulsing circles according to the progress of the active function callbacks. Finally, phase four (see Figure~\ref{fig:didactic-four}) displayed four active functions as circles with a colour fill according to the progress of the active function callbacks.

\input{images/aesthetic-visualisations}

\subsection{Aesthetic Visualisation}
\label{sec:aesthetic-visualisation}

The aesthetic visualisation technique was designed to react to the programmer's activity in a more abstract way, to maximise aesthetic appeal~\cite{Cawthon2007} and to engage the audience's interest. Although still based on the source code and the livecoder's edits, the generation of shapes was driven by instrument volume and synchronised with the musical beat. These were secondary features of the programming language and features resulting from the output of the running program as opposed to the callback rate, a primary feature, used in the didactic visualisations.

The emphasis for the aesthetic visualisation was on the artistic appeal of the visuals (see Figure~\ref{fig:aesthetic-visualisations}), including more variety in visual structure and colour. As in the didactic condition, the aesthetic visualisations proceeded through four stages, based on the number of active functions (instruments), but these visuals had no textual labels and they moved and interacted with each other over the entire projected scene.

As with the didactic visualisations, the aesthetic visualisations proceeded through four stages, again with progression made depending on the number of active functions (instruments).

Phase one (see Figure~\ref{fig:aesthetic-one}) displayed pulsing bars across the screen and indicated the active state of the function. The pulsing bars were matched to the tempo of the music. Phase two (see Figure~\ref{fig:aesthetic-two}) displayed random small coloured squares across the screen, designed to match the musical aesthetic. Phase three (see Figure~\ref{fig:aesthetic-three}) displayed groups of arcs, again designed to match the musical aesthetic. Finally, phase four (see Figure~\ref{fig:aesthetic-four}) displayed four sets of rotating circles, with the size of each set based on the musical output (volume) of an associated function (instrument).

\section{Development}

Development of the visualisations took place in collaboration with a live coder. This collaboration ensured that the visualisations integrated with the live coding performance and that the performance aspects of live coding such as the workflow and the musical progression were not interrupted. Similarly, this collaboration allowed both the visualisations to be influenced by the musical structures common in live coding and the musical structures to be influenced by the expressiveness and limitations of the visualisations.

Development was conducted within the standard live coding environment, in Extempore. The prototype consisted of a set of functions to be used during the performance as a replacement for some existing structures. This consisted of a callback hook labelled \textit{cv-callback} in replacement of Extempore's standard \textit{callback} function. In Extempore, the \textit{callback} function allows for repeatedly calling functions with a time based interval. This structure is fundamental to the musical aspects of live coding, allowing for the sequencing of musical structures and the patterns common in live coding music.

The \textit{cv-callback} function allowed information regarding the dynamic aspects of the running program to be collected for display within the visualisations such as active function names, callback time, beat and duration information specific to each instrument.

Additionally, a \ac{VU} meter function was adapted to the prototype to allow for collecting volume information specific to each active instrument. This would allow for the real musical output of the musical structures to be determined and visualised.

Information from both the \textit{cv-callback} and the \ac{VU} meter were integrated into the visualisation technique. Specifically, the didactic visualisations made use of the \textit{cv-callback} as more precise information about the active functions. The aesthetic visualisations, on the other hand, made use of the \ac{VU} meter as more abstract high level information about the running functions and their output.

To develop the visualisations, Cairo~\cite{Worth2012} was used through Extempore bindings, as the supporting graphics library for visualisation implementation. Visualisations were written in pure xtlang, as part of the Extempore live coding environment. The final prototype consisted of a total of 1000 \ac{SLOC}.

% To ensure 
% Performance and stability were required 

% \subsection{Testing}

% \more

% what other considerations had to be made during development?

\section{Summary}

This chapter has described two sets of visualisations developed in collaboration with a live coding artist in an attempt to visualise the live coding process. The literature (see Chapter~\ref{chap:literature-review}) had identified the need to evaluate the effect of visualisations on audience experience within live coding in terms of the dimensions of enjoyment and understanding. The two sets of visualisations described here each target one of these dimensions with the aesthetic visualisation targeting enjoyment and the didactic visualisations targeting understanding. 

However, evaluation of the two resulting sets of visualisations was required. Although based on the literature and the results of the field study, assumptions made over the course of the development process required careful evaluation within the application space of live coding to confirm or invalidate these visualisations. The following chapter (see Chapter~\ref{chap:user-study}) discusses the evaluation of these visualisations within the space of live coding, further informing future iterations of the visualisation technique and development methodology.



