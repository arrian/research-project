%!TEX root = thesis.tex

\chapter{Visualisation Refinement}
\label{chap:visualisation-refinement}

% \begin{chapquote}{Frederick Brooks, \textit{The Mythical Man-Month}}
% ``Geometric abstractions are powerful tools. The floor plan of a building helps both architect and client evaluate spaces, traffic flows, views. Contradictions become obvious, omissions can be caught. Scale drawings of mechanical parts and stick-figure models of molecules, although abstractions, serve the same purpose. A geometric reality is captured in a geometric abstraction.''
% \end{chapquote}

Following the first user study (Chapter~\ref{chap:user-study}), limitations with both the visualisations and the evaluation method were identified and steps were taken to correct these limitations. The following section summarises the steps taken to correct these limitations.

\section{Rationale}

``the aesthetic of fixing nodes and edges to an underlying unit grid was prominent''~\cite{Purchase2014} (also~\cite{Purchase2001,Purchase1996})

The intial user study, although identifying some improvement in enjoyment through the use of visualisations, had conflict results regarding understanding. This visualisation prototype intended to... \more

A number of technical limitations were identified in the previous iteration of the visualisation prototype including incorrect timing and beat, no direct feedback from the programmer and limited... \more
% -previous study had visualisation limitations eg. missed timing, no direct feedback from the programmer etc

This visualisation prototype built on a combination of the aesthetic and didactic visualsations evaluated in the previous study, taking visual elements identified as postively contributing to understanding and enjoyment. These included... \more
% -strategy employed a combination of the aesthetic and didactic visualisations from the previous study...

-aligning the mental models of audience and programmer

\more

\section{Requirements}

Following the user study, some additional audience requirements were identified. These included the need to 

\section{Design}

-prototype of 2336 SLOC c++, 1310 SLOC xtm, total of 3646 SLOC

\cite{Purchase1996}...

\begin{figure}
  \centering \includegraphics[width=\columnwidth]{../images/diagrams/knowledge-flow-refined.pdf}
  \caption{Knowledge flow from programmer to observer as directed by the visualisation technique employed.}
\label{fig:knowledge-flow-refined}
\end{figure}

\begin{figure}
  \centering \includegraphics[width=\columnwidth]{../images/diagrams/visualisation-class-diagram.pdf}
  \caption{Class diagram of the visualisation technique employed.}
\label{fig:visualisation-class-diagram}
\end{figure}

The visualisation technique employed required three major components including an application manager, a code manager and an editor plugin (see the class diagram in Figure~\ref{fig:visualisation-class-diagram}). The following sections detail the implementation of these components.

\subsection{Visualisation Manager}


-polycode~\cite{Safrin2013}

-opengl

\more

\subsection{Interface Mananger}
\label{sec:interface-manager}

-sublime plugin

-emacs plugin

This was acheived using a text editor plugin sending programmer interactions over an \ac{OSC} protocol. The interactions sent included cursor movement, all source code changes, file focus and source code evaluation.

\more

\subsection{Code Manager}

Both static analysis of source code and the dynamic analysis (see~\cite{Eisenbarth2003} and~\cite{Jerding1997}) of the program were combined into this iteration of the visualisation prototype in order to provide the audience with a link between the \ac{SoW} and the \ac{SoC}~\cite{Swift2013}. {\color{red} explain what the \ac{SoW} and the \ac{SoC} actually is and show the link between the \ac{SoW} with dynamic analysis and the \ac{SoC} with static analysis...}

Static analysis of the source code involved parsing the changing source code input by the programmer. Data requiring this static analysis was received from the editor plugin (see~\ref{sec:interface-manager}) and stored as the current \ac{SoC}.

Dynamic analysis of the running program involved providing mechanisms for the programmer to send running state information to be stored as the \ac{SoW}. {\color{red} explain what was provided a little better} A callback hook was provided to be used when creating an instrument during performance. This hook would provide data on the state of the active instruments and would allow links to be determined between the \ac{SoC} and the \ac{SoW}.

\subsection{Mappings}

A number of specific mappings were assigned to the visualisation. These visual mappings related directly to actions taken by the programmer, behaviour of the running program and representation of the static code. 

Function count was mapped to the number of large visual elements on screen. When adding a new function, a new element was introduced. This mapping was intended to allow the audience to associate the simplified geometric shape to the source code and allow the audience to separate functions visually.

Each large visual element represented the state of active and inactive functions. In live coding, the programmer triggers functions to change between active and inactive states. The mapping represented this though the use of washed out grey and white colours while inactive and vibrant, bright colours while active. In addition, the active functions were animated, with moving visual elements.

Function size and shape was represented visually through the use of ``attractors'' with each line of code mapped to one of the visual elements. Visual elements would grow and shrink according to the length of the line of source code directly mapping the typing actions of the programmer to visual elements.  
% -programmer typing behaviour

% -function beat+callback duration

To ensure the relationship between the actions of the programmer, the changes to the source code and the changes to the music were easily identified, an icon representing the programmer was displayed closest to the function being edited. This mapping intended to provide the audience with a better overview of the movements of the programmer among the functions than would otherwise be visible through the cursor alone.  
% -programmer editing behaviour

{\color{red} Show a table with images and description of behaviour}

\subsection{Testing}

Stability was of primary concern during the live performance...

\section{Summary}

-how does this visualisation fix the issues identified in the previous iteration of the visualisation?

\more


