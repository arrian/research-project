

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Visualisation 1 (Function Symbols) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val VFS_FUNCTION_COUNT i32 0);;pointer to last function in array
(bind-val VFS_FUNCTION_TRANSITION_DURATION float 250000.0);;duration of the intial entry transition
(bind-val VFS_FUNCTION_ARRAY |16,<i1,float,float,float>*|*);;<is_active,size,color,transition_start>

(bind-func vfs_create
  (lambda ()
    (let ((value:<i1,float,float,float>* (halloc)))
      (tfill! value 1 90.0 0.1 (i64tof (now)))
      (aset! VFS_FUNCTION_ARRAY VFS_FUNCTION_COUNT value)
      (set! VFS_FUNCTION_COUNT (+ 1 VFS_FUNCTION_COUNT)
      (- 1 VFS_FUNCTION_COUNT)))))

(bind-func vfs_set_size
  (lambda (index:i32 value:float)
    (tset! (aref VFS_FUNCTION_ARRAY index) 1 value)))

(bind-func func-name
  (lambda ()
    (set! VFS_FUNCTION_COUNT (i64toi32 0))))

(func-name)

;(vfs_set_size 1 110.0)

(bind-func vfs_get_size
  (lambda (index:i32)
    (tref (aref VFS_FUNCTION_ARRAY index) 1)))

(bind-func vfs_set_colour
  (lambda (index:i32 value:float)
    (tset! (aref VFS_FUNCTION_ARRAY index) 2 value)))

(bind-func vfs_get_colour
  (lambda (index:i32)
    (tref (aref VFS_FUNCTION_ARRAY index) 2)))

(bind-func vfs_get_start
  (lambda (index:i32)
    (tref (aref VFS_FUNCTION_ARRAY index) 3)))

(bind-func vfs_pulse
  (lambda (index:i32)
    (vfs_set_size index 120.0)
    void))

(bind-func draw_rectf_centre
  (lambda (xcentre:float ycentre:float size:float)
    (xtm_draw_rectf (- xcentre (/ size 2.0)) (- ycentre (/ size 2.0)) size size)))


;;Math.easeOutQuad = function (t, b, c, d) {
;;  t /= d;
;;  return -c * t*(t-2) + b;
;;};

(bind-func vfs_transition_ease_out_quadratic
  (lambda (index:i32 start:float change:float)
    (let ((current:float (- (i64tof (now)) (vfs_get_start index)))
          (neg_change:float (- 0.0 change)))
      (let ((percent_complete:float (/ current 25000.0)))
        ;(println percent_complete)
        (cond ((> percent_complete 1.0) (change))
        (else (+ start (* (- percent_complete 2.0) (* (neg_change) (percent_complete))))))))))

(define fullscreen #f)

(define width 1024.0)
(define height 768.0)
(bind-val width float width)
(bind-val height float height)

(define *gl-ctx* (gl:make-ctx ":0.0" fullscreen 0.0 0.0 width height))

(xtm_render_setup width height)
(if (<> (xtm-vg-create-context width height) 1) (xtm_vg_print_error))

(bind-func gl_render
  (lambda (time:float)
    (let ((stroke (vgCreatePaint))
          (fill (vgCreatePaint))
          (i:i32 0))
        (xtm_vg_reset_matrices)
        (xtm_vg_clear 0.0 0.0 0.0 1.0 (ftoi32 width) (ftoi32 height))
        
		    (xtm_paint_setup_stroke stroke (dtof 0.5) (dtof 0.6) 0.2 0.5 3.0)
        (dotimes (i VFS_FUNCTION_COUNT)
            (let ((row:float (i32tof (/ i (ftoi32 (/ width 120.0))))) 
                  (col:float (i32tof (% i (ftoi32 (/ width 120.0))))))
              ;(println (vfs_transition_ease_out_quadratic i 0.0 500.0))
              (xtm_paint_setup_fill fill 0.0 1.0 0.0 (vfs_transition_ease_out_quadratic i 0.0 1.0))
              (draw_rectf_centre (+ 90.0 (* col 120.0)) (+ (* row 120.0) (- (vfs_transition_ease_out_quadratic i 0.0 300.0) 200.0)) (vfs_get_size i))
              (if (> (vfs_get_size i) 90.0) (vfs_set_size i (- (vfs_get_size i) 1.0)))
              )
          )
        (xtm_destroy_paint fill)
        (xtm_destroy_paint stroke)
    void)))


(define draw
  (lambda (time)
      (begin
        (gl_render time)
        (gl:swap-buffers *gl-ctx*))))

(define update
  (lambda (beat dur)
    (draw beat)
    (callback (*metro* (+ beat dur)) 'update (+ beat dur)
              dur)))

(update (*metro* 'get-beat 1.0) 1/32)


(println (vfs_create))
(println (vfs_create))






(vfs_pulse 1)

(println (vfs_get_size 0))
(println (vfs_set_size 0 (+ 0.1 (vfs_get_size 0))))




(define drumloop
  (lambda (beat dur)
    ;;(println beat)
    (if (= (modulo beat 1/2) 0)
        (vfs_pulse 0))
    (if (= (modulo beat 1) 0)
        (vfs_pulse 1))
    (if (= (modulo beat 2) 0)
        (vfs_pulse 2))
    (if (= (modulo beat 4) 0)
        (vfs_pulse 3))
    ;;(play kit (cosr 45 9 1/7) (cosr 80 30 1/2) .1)
    ;;(play kit (cosr 59 9 1/9) (cosr 80 30 1/2) (* dur (random '(1/4 1/4 5))) 1)
    (callback (*metro* (+ beat (* .5 dur))) 'drumloop (+ beat dur) dur)))

(drumloop (*metro* 'get-beat 4) 1/4)




;;To Write:
;limiters
;transitions
;beat matcher







(bind-func vfs_transition_ease_out_quadratic
  (lambda (start:float duration:float val_start:float val_change:float)
    ((+ (* (* (- val_change) start) (- start 2.0)) val_change))))







(bind-func vfs_print_count
	(lambda ()
		(println (pref VFS_FUNCTION_COUNT 0))))


(bind-func test_set_tuple
  (lambda ()
    (let ((value:<i1,float,float>* (halloc)))
      (tfill! value 0 0.1 0.2)
      (aset! VFS_FUNCTION_ARRAY 0 value))))

(test_set_tuple)

(bind-func test_get_tuple
  (lambda ()
      (println (tref (aref VFS_FUNCTION_ARRAY 0) 1))))

(test_get_tuple)


;;Creates a new function symbol
(bind-func vfs_create
	(lambda ()
		(let )))

;;Updates the function symbol making it the brightest colour
(bind-func vfs_update)

;;Turns the function symbol to an inactive state 
(bind-func vfs_stop)

;;Pulses the function symbol
(bind-func vfs_pulse) 

(bind-func draw)

(bind-func update)
