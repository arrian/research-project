
(bind-val VU_LEVELS_RMS |16,SAMPLE|*)

(bind-func rms_power
  (lambda (data:SAMPLE* len)
    (let ((data_vec:/4,SAMPLE/* (cast data))
          (sum_vec:/4,SAMPLE/* (alloc))
          (j 0))
      (dotimes (j (/ len 4))
        (pset! sum_vec 0 (+ (* (pref-ptr data_vec j)
                               (pref-ptr data_vec j))
                            sum_vec)))
      (/ (+ (vref sum_vec 0) (vref sum_vec 1)
            (vref sum_vec 2) (vref sum_vec 3))
         (convert len)))))

(bind-func vu_meter_c
  "frame_size must be a multiple of 4 (since the RMS sum is SIMD-optimised)"
  (lambda (ninst frame_size)
    (let ((data:SAMPLE* (zalloc (* ninst frame_size)))
          (counters:i64* (zalloc ninst)))
      (lambda (chan inst_idx in)
        (if (or (< inst_idx 0)
                (> inst_idx ninst)
                (<> chan 0))
            in
            (let ((counter (pref counters inst_idx)))
              (pset! data (+ (* inst_idx frame_size) counter) in)
              (pset! counters inst_idx (% (+ counter 1) frame_size))
              (if (= (% counter frame_size) 0)
                  (aset! VU_LEVELS_RMS inst_idx
                         (rms_power (pref-ptr data (* inst_idx frame_size))
                                    frame_size)))
              in))))))

(bind-func vu_level
  (lambda (inst_idx)
    (if (or (< inst_idx 0)
            (> inst_idx 16))
        (begin (println "Error: index must be between 0 and 16.")
               0.)
        (aref VU_LEVELS_RMS inst_idx))))


;; (define vu-print)
;;   (lambda (beat dur)
;;     (let ((lev0 (* 3000 (vu_level 0)))
;;           (lev1 (* 3000 (vu_level 1))))
;;       (dotimes (i lev0)
;;         (print "*"))
;;       (println)
;;       (dotimes (i lev1)
;;         (print "-"))
;;       (println))
;;     (callback (*metro* (+ beat (* .5 dur))) 'vu-print (+ beat dur) dur)))

;; (vu-print (*metro* 'get-beat 4) 1/16)

;;--------------------------------------------------------------

(define ctx (gl:make-ctx ":0.0" #f 0.0 0.0 900.0 600.0))

(sys:load "libs/external/cairo.xtm")

;; (bind-func add_dsp
;;   (lambda ()
;;     ))

;; (bind-func draw_dsp
;;   (lambda ()
;;     ))


;; (define cairo_show_text
;;   (lambda ()
;;     ))


(bind-func cairo_draw
  (let ((surface (cairo_image_surface_create CAIRO_FORMAT_RGB24 900 600))
  (cr (cairo_create surface)) 
  (i 0.0))
    (lambda (t:double j:i32)
      (cairo_set_operator cr CAIRO_OPERATOR_SOURCE)
      (let ((rgb:RGB* (rgb_from_temperature j)))
          (cairo_set_source_rgba cr (rgb_r rgb) (rgb_g rgb) (rgb_b rgb) 1.0)
        )
      ;(println t)
      (cairo_paint cr)
      
      ;(cairo_set_operator cr CAIRO_OPERATOR_HSL_LUMINOSITY)

      (dotimes (i 300.0)
        ;(cairo_set_source_rgba cr (1.0) 1.0 0.4 (if (> i 5.0) 0.5 1.0))
      (let ((rgb:RGB* (rgb_from_temperature (* (j) (dtoi32 i)))))
          (cairo_set_source_rgba cr (rgb_r rgb) (rgb_g rgb) (rgb_b rgb) 1.0)
        )

        (cairo_set_line_width cr (+ 1.0(* 100.0 (ftod (vu_level 0)))))
        
        (cairo_arc cr
             (+ 450.0 (* 350.0 (cos (* i t .00000003))))
             (+ 300.0 (* 200.0 (sin (* i t .0000002))))
             (+ 10.0 (ftod (* 500.0 (vu_level (if (> i 90.0) 2 0))))) 0.0 TWOPI)
        ;;(cairo_line_to cr 100.0 300.0)
        (cairo_fill cr))
        ;;(cond ((> i 10.0) (cairo_fill cr)) (else (cairo_stroke cr))))

      ;(cairo_set_source_rgb cr (* 10.0 (ftod (vu_level 2))) 0.1 0.05)
      (cairo_move_to cr 100.0 300.0)
      ;(cairo_set_font_size cr 15.0)
      ;;(cairo_show_text cr (get-func-text0 0))
      ;(cairo_show_text cr "test\ntest2\ntest3")


      ;(cairo_surface_flush surface)
      (cairo_image_surface_get_data surface))))
        
(bind-func gl_draw
  (lambda (i:i32)
    (glLoadIdentity)
    (gl_load_tex_bgr 900 600 4 GL_UNSIGNED_BYTE (cairo_draw (i64tod (now)) i) 5)
    (gl_draw_img_reverse -1.0 -1.0 2.0 2.0 180.0 5)
    void))

(define cairo-animation
  (lambda (beat dur i)
    (gl_draw i)
    (gl:swap-buffers ctx)
    (println i)    
    (callback (*metro* (+ beat (* .5 dur))) 'cairo-animation (+ beat dur) dur (if (>= i 30000) 0 (+ i 100)))))

(cairo-animation (*metro* 'get-beat 4) 1/20 0)


;;--------------------------------------------------------------

(define-sampler kit sampler_note_hermite_c sampler_fx)

(bind-func dsp:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* 100000
  ;; VU metering at 30Hz, 4 distinct channels
  (let ((vu_meter (vu_meter_c 8 (/ 44100 15))))
    (lambda (in time chan dat)
      (+ 
         (vu_meter chan 1 (* 0.5 (epad in time chan dat)))
         (vu_meter chan 2 (* 0.5 (fmsynth in time chan dat)))
         (vu_meter chan 0 (* 2.0 (kit in time chan dat)))
         ))))

(dsp:set! dsp)


(play-note (now) kit (random '(46 47)) 80 44100)


(define fsynth
  (lambda (beat dur)
    (play-note (now) epad (random '(55 60 60 67 72)) 70 44100)
    (callback (*metro* (+ beat (* 4.0 dur))) 'fsynth (+ beat dur) dur)))

(fsynth (*metro* 'get-beat 4) 1/4)


(define fsynth2
  (lambda (beat dur)
    (play-note (now) fmsynth (random '(20 55 72)) 80 44100)
    (callback (*metro* (+ beat (* 1.0 dur))) 'fsynth2 (+ beat dur) dur)))

(fsynth2 (*metro* 'get-beat 4) 1/2)


;;------------------------------
(define *user-sample-dir* "/Users/arrian/Projects/Music/Assets/samples")
(load "/Users/arrian/Dev/extempore-hackday/sampler-maps.xtm")

(sm-load-map kit *808-kit-map*)

(define drumloop
  (lambda (beat dur)
    (if (= (modulo beat 1) 0)
        (play kit (random 46 64) 120 dur))
    (if (= (modulo beat 1/2) 0)
      
        (play kit (random 47 55) 90 dur))
    (if (= (modulo beat 1/1) 0)
      (play kit 54 100 (* 2.0 dur)))
    (callback (*metro* (+ beat (* .5 dur))) 'drumloop (+ beat dur) dur)))

(drumloop (*metro* 'get-beat 4) 1/4)






