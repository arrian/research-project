
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Visualisation utility functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-val VU_LEVELS_RMS |16,SAMPLE|*)

(bind-val SOUND_ARRAY |25,float|*)

(bind-func fill_sound_array
  (lambda ()
    (let ((j 0))
      (dotimes (j 25)
        (pset! SOUND_ARRAY j 0.0)))))

(bind-val SOUND_ARRAY2 |25,float|*)

(bind-func fill_sound_array
  (lambda ()
    (let ((j 0))
      (dotimes (j 25)
        (pset! SOUND_ARRAY2 j 0.0)))))

(fill_sound_array)


(bind-func rms_power
  (lambda (data:SAMPLE* len)
    (let ((data_vec:/4,SAMPLE/* (cast data))
          (sum_vec:/4,SAMPLE/* (alloc))
          (j 0))
      (dotimes (j (/ len 4))
        (pset! sum_vec 0 (+ (* (pref-ptr data_vec j)
                               (pref-ptr data_vec j))
                            sum_vec)))
      (/ (+ (vref sum_vec 0) (vref sum_vec 1)
            (vref sum_vec 2) (vref sum_vec 3))
         (convert len)))))

(bind-func vu_meter_c
  "frame_size must be a multiple of 4 (since the RMS sum is SIMD-optimised)"
  (lambda (ninst frame_size)
    (let ((data:SAMPLE* (zalloc (* ninst frame_size)))
          (counters:i64* (zalloc ninst)))
      (lambda (chan inst_idx in)
        (if (or (< inst_idx 0)
                (> inst_idx ninst)
                (<> chan 0))
            in
            (let ((counter (pref counters inst_idx)))
              (pset! data (+ (* inst_idx frame_size) counter) in)
              (pset! counters inst_idx (% (+ counter 1) frame_size))
              (if (= (% counter frame_size) 0)
                  (aset! VU_LEVELS_RMS inst_idx
                         (rms_power (pref-ptr data (* inst_idx frame_size))
                                    frame_size)))
              in))))))

(bind-func vu_level
  (lambda (inst_idx)
    (if (or (< inst_idx 0)
            (> inst_idx 16))
        (begin (println "Error: index must be between 0 and 16.")
               0.)
        (aref VU_LEVELS_RMS inst_idx))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Audio demo
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func dsp:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* 100000
  ;; VU metering at 30Hz, 4 distinct channels
  (let ((vu_meter (vu_meter_c 8 (/ 44100 15))))
    (lambda (in time chan dat)
      (+ (vu_meter chan 0 (* (random 0.1) (cos (/ (* STWOPI (convert time) 1.0) SR))))
         (vu_meter chan 1 (* (random 0.1) (cos (/ (* STWOPI (convert time) 0.5) SR))))))))

(dsp:set! dsp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Graphical context
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define fullscreen #f)

(define width 1024.0)
(define height 768.0)
(bind-val width float width)
(bind-val height float height)

(define *gl-ctx* (gl:make-ctx ":0.0" fullscreen 0.0 0.0 width height))

(xtm_render_setup width height)
(if (<> (xtm-vg-create-context width height) 1) (xtm_vg_print_error))


(bind-func gl_render
  (lambda (time:float)
    (let ((stroke (vgCreatePaint))
          (fill (vgCreatePaint))
          (lev0:float (* 30000.0 (vu_level 0)))
          (lev1:float (* 30000.0 (vu_level 1)))
          (i:i32 0))
        (xtm_vg_reset_matrices)
        (xtm_vg_clear 0.0 0.0 0.0 1.0 (ftoi32 width) (ftoi32 height))
        (xtm_paint_setup_fill fill 1.0 0.2 0.0 1.0)
    	;(xtm_paint_setup_stroke stroke (dtof (random 0.3 0.9)) (dtof (random 0.5 0.7)) 0.2 0.5 5.0) 
		
		
		(dotimes (i 1)
			(xtm_draw_rectf (+ 200.0 (* (i32tof i) 10.0)) 400.0 400.0 lev0)
			(xtm_draw_rectf (+ 200.0 (* (i32tof i) 10.0)) 200.0 400.0 lev1))

        (xtm_destroy_paint fill)
        (xtm_destroy_paint stroke)
    void)))


(define draw
  (lambda (time)
      (begin
        (gl_render time)
        (gl:swap-buffers *gl-ctx*))))

(define update
  (lambda (beat dur)
    (draw beat)
    (callback (*metro* (+ beat dur)) 'update (+ beat dur)
              dur)))

(update (*metro* 'get-beat 1.0) 1/32)







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Visualisation 3 (Abstract Pulse) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func vab_pulse)

(bind-func draw)

(bind-func update)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Visualisation 2 (Instrument frequency spectrum) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Need map containing all instruments, plus previous spectrum

;; Creates the instrument image
(bind-func vspec_create)

;; Draws the wave form for the instruments
(bind-func draw)

(bind-func update)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Visualisation 3 (Instrument beat) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Need map containing all instruments, plus previous beats

;; Creates the instrument image
(bind-func vbeat_create)

;; Pulses the instrument
(bind-func vbeat_pulse)

;; Draws the beat for the instruments
(bind-func draw)

(bind-func update)




(define vu-print
  (lambda (beat dur)
    (let ((lev0 (* 3000 (vu_level 0)))
          (lev1 (* 3000 (vu_level 1))))
      (dotimes (i lev0)
        (print "*"))
      (println)
      (dotimes (i lev1)
        (print "-"))
      (println))
    (callback (*metro* (+ beat (* .5 dur))) 'vu-print (+ beat dur) dur)))

(vu-print (*metro* 'get-beat 4) 1/16)





